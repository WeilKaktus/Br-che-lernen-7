<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schoko-Bruch Abenteuer!</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial Rounded MT Bold', sans-serif;
            display: grid;
            place-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f8ff; 
            color: #4a4a4a; 
            padding: 20px;
            box-sizing: border-box;
        }
        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff; 
            padding: 25px;
            border-radius: 20px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 650px; 
        }
        .page {
            width: 100%;
        }
        #canvasContainer {
            margin-bottom: 20px;
            border: 3px dashed #ffcc5c; 
            border-radius: 10px; 
            overflow: hidden; 
            background-color: #fff; 
            width: 340px; 
            height: 260px; 
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #problemCanvasContainer {
            margin-bottom: 20px;
            border: 3px dashed #66a6ff;
            border-radius: 10px;
            overflow: hidden;
            background-color: #f7faff;
            width: 340px; 
            height: 260px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .explanation-area, #problemText {
            background-color: #lightgreen; 
            border: 2px solid #90ee90; 
            color: #333; 
            padding: 15px 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            min-height: 90px; 
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1.2em; 
            line-height: 1.6;
            width: 100%;
            box-sizing: border-box;
            font-weight: bold;
        }
        #problemText {
            background-color: #e0f7fa;
            border-color: #4dd0e1;
        }
        .navigation-buttons { 
            display: flex;
            gap: 15px;
            margin-top: 10px;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }
        .controls, #problemPageContent {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
            margin-top: 10px; 
            margin-bottom: 20px;
            width: 100%;
        }
        .control-group {
            display: flex;
            flex-direction: column; 
            align-items: center;
            gap: 8px;
            width: 100%;
            max-width: 300px; 
        }
        label {
            font-size: 1.1em; 
            font-weight: bold;
            color: #5d4037; 
        }
        input[type="number"] {
            padding: 12px;
            border: 2px solid #87ceeb; 
            border-radius: 10px;
            width: 100px;
            font-size: 1.1em;
            text-align: center;
            box-sizing: border-box;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
        }
        h1 {
            color: #ff4500; 
            margin-bottom: 25px;
            text-align: center;
            font-size: 2.2em; 
        }
        p.hinweis {
            font-size: 1em;
            color: #4682b4; 
            text-align: center;
            max-width: 500px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        button {
            background-image: linear-gradient(to bottom, #ffd700, #ffa500); 
            color: #4b3832; 
            border: 2px solid #daa520; 
            padding: 15px 30px; 
            font-size: 1.2em;
            font-weight: bold;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0px 4px 0px #b8860b; 
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
        }
        button#prevButton, button#backToMainButton { 
             background-image: linear-gradient(to bottom, #silver, #gray);
             border-color: #darkgray;
             box-shadow: 0px 4px 0px #555;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px #b8860b;
        }
         button#prevButton:hover, button#backToMainButton:hover {
            box-shadow: 0px 6px 0px #555;
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0px 2px 0px #b8860b;
        }
        button#prevButton:active, button#backToMainButton:active {
            box-shadow: 0px 2px 0px #555;
        }
        button:disabled {
            background-image: linear-gradient(to bottom, #d3d3d3, #a9a9a9); 
            color: #666;
            border-color: #888;
            box-shadow: 0px 4px 0px #666;
            cursor: not-allowed;
        }
        #geminiButton, #tasksButton { 
            background-image: linear-gradient(to bottom, #89f7fe, #66a6ff);
            border-color: #558dff;
            box-shadow: 0px 4px 0px #406ac8;
            margin-top: 15px;
        }
         #geminiButton:hover, #tasksButton:hover {
            box-shadow: 0px 6px 0px #406ac8;
        }
        #geminiButton:active, #tasksButton:active {
             box-shadow: 0px 2px 0px #406ac8;
        }
        #nextProblemButton {
            background-image: linear-gradient(to bottom, #50C878, #2E8B57);
            border-color: #2E8B57;
            box-shadow: 0px 4px 0px #1A522E;
        }
        #nextProblemButton:hover {
             box-shadow: 0px 6px 0px #1A522E;
        }
        #nextProblemButton:active {
             box-shadow: 0px 2px 0px #1A522E;
        }
        #submitMarkingButton {
             background-image: linear-gradient(to bottom, #50C878, #2E8B57);
             border-color: #2E8B57;
             box-shadow: 0px 4px 0px #1A522E;
        }
        #submitMarkingButton:hover {
             box-shadow: 0px 6px 0px #1A522E;
        }
        #submitMarkingButton:active {
             box-shadow: 0px 2px 0px #1A522E;
        }
        #answerOptions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }
        .answer-btn {
            padding: 20px 10px;
            font-size: 1.5em;
            font-weight: bold;
        }
        .correct-outline {
            border: 5px solid #4CAF50 !important;
            box-shadow: 0px 0px 10px #4CAF50 !important;
        }
        #feedbackArea {
            margin-top: 15px;
            font-size: 1.5em;
            font-weight: bold;
            min-height: 40px;
        }
        #feedbackArea.correct { color: #2ecc71; }
        #feedbackArea.incorrect { color: #e74c3c; }
        #problemAreaLoading {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 10px;
            font-size: 1.2em;
        }
        .loader {
            border: 6px solid #f3f3f3;
            border-radius: 50%;
            border-top: 6px solid #3498db;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none !important;
        }
        .task-button-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            max-width: 300px;
        }
        .task-button {
            background-image: linear-gradient(to bottom, #ffeb3b, #fbc02d);
            border-color: #f9a825;
            box-shadow: 0px 4px 0px #f57f17;
            font-size: 1.1em;
            flex-grow: 1;
        }
        .task-button:hover {
            box-shadow: 0px 6px 0px #f57f17;
        }
        .help-button {
            background-image: linear-gradient(to bottom, #d3d3d3, #a9a9a9);
            border: 2px solid #888;
            box-shadow: 0px 4px 0px #666;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            padding: 0;
            font-size: 1.5em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .help-button:hover {
            box-shadow: 0px 6px 0px #555;
            transform: translateY(-2px);
        }
        .help-button:active {
            box-shadow: 0px 2px 0px #555;
            transform: translateY(1px);
        }
        .help-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .help-modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: left;
        }
        .help-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 2em;
            cursor: pointer;
            color: #888;
        }
        .frac-container {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            font-size: 1.5em;
        }
        .numerator, .denominator {
            line-height: 1;
        }
        .fraction-bar {
            height: 2px;
            background-color: #000;
            width: 100%;
        }
        #scoreDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #66a6ff;
            color: white;
            padding: 10px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 1.1em;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }
        #levelUpMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #50C878;
            color: white;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 2em;
            font-weight: bold;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 1001;
            animation: fadeOut 3s forwards;
            white-space: nowrap;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; display: none; }
        }
    </style>
</head>
<body>
    <main>
        <div id="scoreDisplay">
            <span>Punkte: <span id="scoreValue">0</span></span>
            <span>Level: <span id="levelValue">1</span></span>
        </div>
        <div id="levelUpMessage" class="hidden"></div>

        <div id="mainPage" class="page">
            <h1>Dein Schoko-Bruch Abenteuer!</h1>
            <div class="explanation-area" id="explanationText">
                Hallo, kleiner Entdecker! Bist du bereit f√ºr ein Schoko-Abenteuer? Los geht's!
            </div>
            <div id="canvasContainer"></div>
            <div class="navigation-buttons">
                <button id="prevButton" disabled>Zur√ºck</button>
                <button id="nextButton">Weiter geht's!</button>
            </div>
            <div class="controls hidden" id="interactiveControls">
                <p class="hinweis">Klasse! Jetzt bist du der Schoko-Meister! Probier selbst aus, wie viele St√ºcke du teilen und naschen kannst!</p>
                <div class="control-group">
                    <label for="nennerInput">In so viele St√ºcke teilen:</label>
                    <input type="number" id="nennerInput" value="4" min="1" max="12"> </div>
                <div class="control-group">
                    <label for="zaehlerInput">So viele St√ºcke nehm' ich mir:</label>
                    <input type="number" id="zaehlerInput" value="1" min="0" max="12">
                </div>
                <!-- Der Button wurde umfunktioniert, um direkt zur Aufgabenseite zu leiten, da die KI-Funktion entfernt wurde -->
                <button id="geminiButton">Interaktive Aufgaben</button> 
            </div>
            <div class="navigation-buttons">
                 <button id="tasksButton">Aufgaben-Training</button> 
            </div>
        </div>

        <div id="taskTypesPage" class="page hidden">
            <h1>W√§hle deine Aufgabe!</h1>
            <div class="explanation-area">
                W√§hle eine Kategorie, um dein Bruch-Wissen zu testen.
            </div>
            <div id="taskOptions" class="controls">
                <!-- NEUE AUFGABE HINZUGEF√úGT -->
                <div class="task-button-container">
                    <button class="task-button" data-task-type="markFraction">Br√ºche markieren</button>
                    <button class="help-button" data-task-type="visualFraction">?</button>
                </div>
                <div class="task-button-container">
                    <button class="task-button" data-task-type="visualFraction">Br√ºche darstellen</button>
                    <button class="help-button" data-task-type="visualFraction">?</button>
                </div>
                <div class="task-button-container">
                    <button class="task-button" data-task-type="fractionOfQuantity">Bruchteile bestimmen</button>
                    <button class="help-button" data-task-type="fractionOfQuantity">?</button>
                </div>
                <div class="task-button-container">
                    <button class="task-button" data-task-type="expandFraction">Br√ºche erweitern</button>
                    <button class="help-button" data-task-type="expandFraction">?</button>
                </div>
                <div class="task-button-container">
                    <button class="task-button" data-task-type="reduceFraction">Br√ºche k√ºrzen</button>
                    <button class="help-button" data-task-type="reduceFraction">?</button>
                </div>
                <div class="task-button-container">
                    <button class="task-button" data-task-type="fractionToDecimal">Br√ºche in Dezimalzahlen</button>
                    <button class="help-button" data-task-type="fractionToDecimal">?</button>
                </div>
            </div>
            <div class="navigation-buttons">
                <button id="backFromTaskTypesButton">Zur√ºck zum Abenteuer</button>
            </div>
        </div>

        <div id="problemPage" class="page hidden">
            <h1>Aufgaben-R√§tsel!</h1>
            <div id="problemPageContent">
                </div>
            <div class="navigation-buttons">
                 <button id="backToMainButton">Zur√ºck zum Abenteuer</button>
            </div>
        </div>
        
        <div id="helpModal" class="help-modal-overlay hidden">
            <div class="help-modal-content">
                <span id="closeHelpModal" class="help-modal-close">&times;</span>
                <div id="helpContent"></div>
            </div>
        </div>

    </main>

    <script>
        // Global variables
        let nennerInput, zaehlerInput, explanationTextDiv, nextButton, prevButton, geminiButton, backToMainButton;
        let interactiveControlsDiv, mainPage, problemPage, problemPageContent;
        let schokoSketch, problemSketch, tasksButton, taskTypesPage, backFromTaskTypesButton;
        let nenner = 1, zaehler = 1, animationsSchritt = 0;
        let currentTaskType = null;
        let score = 0;
        let level = 1;
        let answered = false;
        
        // NEUER ZUSTAND F√úR INTERAKTIVE AUFGABEN
        let interactiveTaskState = {
            correct_numerator: 0,
            total_denominator: 0,
            markedParts: [], // Speichert den Zustand der markierten Teile (true/false)
            canvasWidth: 300,
            canvasHeight: 220,
            gridWidth: 200,
            gridHeight: 100
        };
        
        // ** API Key wurde entfernt, da die App ohne KI arbeiten soll **

        const LEVEL_UP_THRESHOLDS = [5, 10, 20, 40, 70, 100]; // Punkte, um das n√§chste Level zu erreichen
        const LEVEL_COMMENTS = {
            1: "Klasse!",
            2: "Weiter so!",
            3: "Fantastisch!",
            4: "Du bist unschlagbar!",
            5: "Meister der Br√ºche!",
            6: "Professor der Mathematik!"
        };

        const animationsSequenz = [
            { text: "Hallo, Schoko-Fan! Schau mal, hier ist EINE ganze Tafel leckere Schokolade!", n: 1, z: 1, showBruchSymbol: false },
            { text: "Diese ganze Tafel geh√∂rt uns! Das ist 1 von 1 Teil.", n: 1, z: 1, showBruchSymbol: false }, 
            { text: "Stell dir vor, du willst mit einem Freund teilen. Knacks! Du brichst die Schokolade genau in der Mitte durch. Jetzt gibt es ZWEI gleich gro√üe St√ºcke!", n: 2, z: 0, showBruchSymbol: false, nennerFokus: true }, 
            { text: "Siehst du die Zahl UNTEN? Das ist der Nenner. Die 2 sagt uns: 'Die Schokolade ist jetzt in 2 superfaire St√ºcke geteilt!'", n: 2, z: 0, showBruchSymbol: true, showOnlyNennerRelevant: true, nennerFokus: true },
            { text: "Wenn du dir EIN St√ºck davon schnappst, hast du 1 von den 2 St√ºcken. Das ist dann die H√§lfte!", n: 2, z: 1, showBruchSymbol: true, zaehlerFokus: true },
            { text: "Und die Zahl OBEN? Das ist der Z√§hler. Die 1 sagt uns: 'Du hast dir gerade 1 tolles St√ºck ausgesucht!'", n: 2, z: 1, showBruchSymbol: true, zaehlerFokus: true },
            { text: "Was, wenn noch ein Freund kommt? Dann teilst du die Schokolade in DREI St√ºcke. Der Nenner ist dann 3.", n: 3, z: 0, showBruchSymbol: true, showOnlyNennerRelevant: true, nennerFokus: true },
            { text: "Und wenn du dir ZWEI von diesen drei St√ºcken nimmst? Dann hast du 2 von 3 St√ºcken.", n: 3, z: 2, showBruchSymbol: true, zaehlerFokus: true },
            { text: "Stell dir vor, die Tafel wird in 4 St√ºcke geteilt und du nimmst ALLE 4! Mmmh! Dann hast du wieder die GANZE Schokolade!", n: 4, z: 4, showBruchSymbol: true },
            { text: "Oder du teilst in 6 St√ºcke und nimmst dir 5 davon. Fast die ganze Tafel!", n: 6, z: 5, showBruchSymbol: true },
            { text: "Merk dir: Die Zahl UNTEN (Nenner) verr√§t, in wie viele St√ºcke alles geteilt ist. Die Zahl OBEN (Z√§hler) verr√§t, wie viele St√ºcke du dir anschaust oder nimmst!", n: 'N', z: 'Z', showBruchSymbol: true }, 
            { text: "Spitze! Du bist ein echter Bruch-Experte! Jetzt darfst du selbst zaubern!", n: 4, z: 1, showBruchSymbol: true } 
        ];

        // Constants
        const SCHOKO_FARBE_GANZ = [101, 67, 33]; 
        const SCHOKO_FARBE_GENOMMEN = [210, 105, 30]; 
        const LINIE_FARBE = [255, 255, 255];
        const ZAEHLER_FARBE = [0, 100, 255]; 
        const NENNER_FARBE = [255, 0, 0];   
        const BRUCHSTRICH_FARBE = [0, 0, 0]; 
        const FOKUS_UMRANDUNG_ZAEHLER = [52, 152, 219]; 
        const FOKUS_UMRANDUNG_NENNER = [231, 76, 60];   
        const SCHOKO_BREITE = 300;
        const SCHOKO_HOEHE = 150;
        const RAND_ABSTAND = 20;
        const BRUCH_TEXT_GROESSE = 48;
        const CANVAS_HOEHE_EXTRA = 70; 
        
        function setup() {
            loadScore(); 
            updateScoreDisplay(); 

            mainPage = select('#mainPage');
            problemPage = select('#problemPage');
            problemPageContent = select('#problemPageContent');
            explanationTextDiv = select('#explanationText');
            nextButton = select('#nextButton');
            prevButton = select('#prevButton'); 
            interactiveControlsDiv = select('#interactiveControls');
            nennerInput = select('#nennerInput');
            zaehlerInput = select('#zaehlerInput');
            geminiButton = select('#geminiButton'); 
            backToMainButton = select('#backToMainButton');
            tasksButton = select('#tasksButton');
            taskTypesPage = select('#taskTypesPage');
            backFromTaskTypesButton = select('#backFromTaskTypesButton');

            nextButton.mousePressed(naechsterSchritt);
            prevButton.mousePressed(vorherigerSchritt); 
            geminiButton.mousePressed(showTaskTypesPage); 
            backToMainButton.mousePressed(showMainPage);
            nennerInput.input(aktualisiereDurchInteraktion);
            zaehlerInput.input(aktualisiereDurchInteraktion);

            tasksButton.mousePressed(showTaskTypesPage);
            backFromTaskTypesButton.mousePressed(showMainPage);
            
            selectAll('.task-button').forEach(button => {
                button.mousePressed(() => {
                    const taskType = button.attribute('data-task-type');
                    generateSpecificTaskLocal(taskType); 
                });
            });

            selectAll('.help-button').forEach(button => {
                button.mousePressed(() => {
                    const taskType = button.attribute('data-task-type');
                    showHelp(taskType);
                });
            });
            
            select('#closeHelpModal').mousePressed(closeHelpModal);


            schokoSketch = new p5(p => {
                p.setup = function() {
                    let canvas = p.createCanvas(SCHOKO_BREITE + 2 * RAND_ABSTAND, SCHOKO_HOEHE + 2 * RAND_ABSTAND + CANVAS_HOEHE_EXTRA);
                    canvas.parent('canvasContainer');
                    p.noLoop();
                    aktualisiereUiZustand(); 
                };
                p.draw = mainDrawFunction;
            });
        }
        
        // Hilfsfunktion: Zuf√§llige Ganzzahl
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Hilfsfunktion: Gr√∂√üter gemeinsamer Teiler (GCD)
        function gcd(a, b) {
            return b ? gcd(b, a % b) : a;
        }

        // Hilfsfunktion: Plausible falsche Br√ºche
        function generateWrongFractions(z, n, correct) {
            let wrongs = new Set();
            wrongs.add(`${n}/${z}`); // Z√§hler und Nenner vertauscht
            wrongs.add(`${z + 1}/${n}`); // Z√§hler + 1
            wrongs.add(`${z}/${n + 1}`); // Nenner + 1
            
            let tempArray = Array.from(wrongs).filter(w => w !== correct).slice(0, 3);
            
            // F√ºlle mit weiteren zuf√§lligen Br√ºchen auf, falls n√∂tig
            while (tempArray.length < 3) {
                let randomN = getRandomInt(2, 8);
                let randomZ = getRandomInt(1, randomN);
                let wrongFrac = `${randomZ}/${randomN}`;
                if (wrongFrac !== correct && !tempArray.includes(wrongFrac)) {
                    tempArray.push(wrongFrac);
                }
            }
            return tempArray.slice(0, 3);
        }

        // Hilfsfunktion: Plausible falsche Zahlen
        function generateWrongNumbers(correct) {
            const correctNum = Number(correct);
            let wrongs = new Set();
            wrongs.add(String(correctNum + 1));
            wrongs.add(String(correctNum - 1));
            wrongs.add(String(correctNum * 2));
            wrongs.add(String(correctNum / 2));
            
            let tempArray = Array.from(wrongs).filter(w => !isNaN(Number(w)) && w !== correct && Number(w) >= 0).slice(0, 3);
            
             while (tempArray.length < 3) {
                let randomNum = getRandomInt(1, 30);
                let wrongNum = String(randomNum);
                if (wrongNum !== correct && !tempArray.includes(wrongNum)) {
                    tempArray.push(wrongNum);
                }
            }
            return tempArray.slice(0, 3);
        }
        
        // Hilfsfunktion: Plausible falsche Dezimalzahlen
        function generateWrongDecimals(correct) {
            const correctNum = Number(correct);
            let wrongs = new Set();
            wrongs.add(String(correctNum + 0.1).substring(0, 5));
            wrongs.add(String(correctNum - 0.1).substring(0, 5));
            wrongs.add(String(1 - correctNum).substring(0, 5)); // Komplement√§rwert
            
            let tempArray = Array.from(wrongs).filter(w => !isNaN(Number(w)) && w !== correct && Number(w) >= 0).slice(0, 3);
            
             while (tempArray.length < 3) {
                let randomDecimal = Math.round(Math.random() * 100) / 100; // 0.00 bis 1.00
                let wrongDecimal = String(randomDecimal);
                if (wrongDecimal !== correct && !tempArray.includes(wrongDecimal)) {
                    tempArray.push(wrongDecimal);
                }
            }
            return tempArray.slice(0, 3);
        }

        /**
         * NEUE LOKALE FUNKTION ZUR AUFGABENGENERIERUNG
         */
        function generateSpecificTaskLocal(taskType) {
            answered = false;
            currentTaskType = taskType;
            taskTypesPage.addClass('hidden');
            problemPage.removeClass('hidden');
            problemPageContent.html('<div id="problemAreaLoading"><div class="loader"></div><p>Denke mir eine coole Aufgabe aus...</p></div>');
            
            let problemData = {};
            let z, n, factor, quantity;
            
            switch(taskType) {
                case 'markFraction':
                    n = getRandomInt(3, 8); // Nenner 3-8
                    z = getRandomInt(1, n - 1); // Z√§hler 1 bis N-1
                    problemData.problem_text = `Markiere die Schokost√ºcke, um den Bruch {${z}/${n}} darzustellen. Klicke auf die St√ºcke, die du nehmen w√ºrdest.`;
                    problemData.correct_answer = `${z}/${n}`; // F√ºr Anzeige/Debugging
                    problemData.correct_numerator = z; 
                    problemData.total_denominator = n; 
                    problemData.wrong_answers = []; // Nicht ben√∂tigt, aber zur Vollst√§ndigkeit
                    break;

                case 'visualFraction':
                    n = getRandomInt(2, 7); // Nenner 2-7
                    z = getRandomInt(1, n); // Z√§hler 1-Nenner
                    problemData.problem_text = "Welcher Bruch wird durch die blau schraffierte Fl√§che dargestellt?";
                    problemData.correct_answer = `${z}/${n}`;
                    problemData.wrong_answers = generateWrongFractions(z, n, problemData.correct_answer);
                    break;

                case 'fractionOfQuantity':
                    n = getRandomInt(2, 5); // Nenner 2-5
                    quantity = getRandomInt(2, 6) * n; // Menge, die durch N teilbar ist
                    z = getRandomInt(1, n - 1); // Z√§hler 1-Nenner
                    let result = (quantity / n) * z;
                    
                    const context_objects = ["√Ñpfeln", "Murmeln", "Stiften", "Gummib√§rchen"];
                    const object = context_objects[getRandomInt(0, context_objects.length - 1)];
                    
                    problemData.problem_text = `Du hast ${quantity} ${object} gesammelt. Dein Freund nimmt {${z}/${n}} davon. Wie viele ${object} nimmt er sich?`;
                    problemData.correct_answer = String(result);
                    problemData.wrong_answers = generateWrongNumbers(problemData.correct_answer);
                    break;

                case 'expandFraction':
                    n = getRandomInt(3, 7); // Nenner 3-7
                    z = getRandomInt(1, n - 1); // Z√§hler 1-Nenner
                    factor = getRandomInt(2, 3); // Erweiterungsfaktor 2 oder 3
                    
                    problemData.problem_text = `Erweitere den Bruch {${z}/${n}} mit der Zahl ${factor}. W√§hle den neuen Bruch.`;
                    problemData.correct_answer = `${z * factor}/${n * factor}`;
                    problemData.wrong_answers = generateWrongFractions(z * factor, n * factor, problemData.correct_answer);
                    break;

                case 'reduceFraction':
                    factor = getRandomInt(2, 3); // K√ºrzungsfaktor 2 oder 3
                    let nSimple = getRandomInt(3, 7); 
                    let zSimple = getRandomInt(1, nSimple - 1);
                    n = nSimple * factor;
                    z = zSimple * factor;

                    problemData.problem_text = `K√ºrze den Bruch {${z}/${n}} vollst√§ndig. W√§hle den gek√ºrzten Bruch.`;
                    problemData.correct_answer = `${zSimple}/${nSimple}`;
                    problemData.wrong_answers = generateWrongFractions(zSimple, nSimple, problemData.correct_answer);
                    break;

                case 'fractionToDecimal':
                    const validNenner = [2, 4, 5, 10]; // Einfache Nenner f√ºr Dezimalzahlen
                    n = validNenner[getRandomInt(0, validNenner.length - 1)];
                    z = getRandomInt(1, n - 1);
                    
                    let decimalResult = z / n;
                    problemData.problem_text = `Wandle den Bruch {${z}/${n}} in eine Dezimalzahl (Kommazahl) um.`;
                    problemData.correct_answer = String(decimalResult);
                    problemData.wrong_answers = generateWrongDecimals(problemData.correct_answer);
                    break;
            }

            // Sicherstellen, dass die problem_text mit Mathe-HTML gerendert wird, bevor sie angezeigt wird
            problemData.problem_text = renderMathHtml(problemData.problem_text); 
            displayProblem(problemData);
        }
        
        function loadScore() {
            const savedScore = localStorage.getItem('score');
            const savedLevel = localStorage.getItem('level');
            score = savedScore ? parseInt(savedScore) : 0;
            level = savedLevel ? parseInt(savedLevel) : 1;
        }

        function saveScore() {
            localStorage.setItem('score', score);
            localStorage.setItem('level', level);
        }

        function updateScoreDisplay() {
            select('#scoreValue').html(score);
            select('#levelValue').html(level);
        }

        function showLevelUpMessage(newLevel) {
            const messageDiv = select('#levelUpMessage');
            messageDiv.html(`Level Up! ${LEVEL_COMMENTS[newLevel] || "Wow!"}`);
            messageDiv.removeClass('hidden');
            setTimeout(() => {
                messageDiv.addClass('hidden');
            }, 3000);
        }

        // --- Core Application Logic ---

        function naechsterSchritt() {
            if (animationsSchritt < animationsSequenz.length - 1) {
                animationsSchritt++;
            } else {
                animationsSchritt = animationsSequenz.length; 
            }
            aktualisiereUiZustand();
        }

        function vorherigerSchritt() {
            if (animationsSchritt > 0) {
                animationsSchritt--;
            }
            aktualisiereUiZustand();
        }
        
        function showMainPage() {
            problemPage.addClass('hidden');
            taskTypesPage.addClass('hidden');
            mainPage.removeClass('hidden');
            if (problemSketch) {
                problemSketch.remove();
                problemSketch = null;
            }
        }

        function showTaskTypesPage() {
            mainPage.addClass('hidden');
            problemPage.addClass('hidden');
            taskTypesPage.removeClass('hidden');
            if (problemSketch) {
                problemSketch.remove();
                problemSketch = null;
            }
        }
        
        function closeHelpModal() {
            select('#helpModal').addClass('hidden');
        }

        function aktualisiereUiZustand() {
            if (animationsSchritt < animationsSequenz.length) {
                // Animation mode
                mainPage.removeClass('hidden');
                problemPage.addClass('hidden');
                taskTypesPage.addClass('hidden');
                interactiveControlsDiv.addClass('hidden');
                nextButton.removeClass('hidden');
                prevButton.removeClass('hidden');
                const aktuellerSchritt = animationsSequenz[animationsSchritt];
                explanationTextDiv.html(aktuellerSchritt.text);
                if (aktuellerSchritt.n === 'N') { nenner = -1; zaehler = -1; } 
                else { nenner = aktuellerSchritt.n; zaehler = aktuellerSchritt.z; }
                prevButton.elt.disabled = (animationsSchritt === 0);
                nextButton.html(animationsSchritt === animationsSequenz.length - 1 ? 'Selber machen!' : 'Weiter geht\'s!');
            } else {
                // Interactive mode
                mainPage.removeClass('hidden');
                problemPage.addClass('hidden');
                taskTypesPage.addClass('hidden');
                explanationTextDiv.html("Klasse! Jetzt bist du der Schoko-Meister! Probier selbst aus, wie viele St√ºcke du teilen und naschen kannst!");
                nextButton.addClass('hidden'); 
                prevButton.removeClass('hidden');
                prevButton.elt.disabled = false;
                interactiveControlsDiv.removeClass('hidden');
                nenner = parseInt(nennerInput.value());
                zaehler = parseInt(zaehlerInput.value());
                if (isNaN(nenner) || nenner < 1) nenner = 4; 
                if (isNaN(zaehler) || zaehler < 0 || zaehler > nenner) zaehler = 1; 
                nennerInput.value(nenner);
                zaehlerInput.value(zaehler);
            }
            if(schokoSketch) schokoSketch.redraw();
        }
        
        function aktualisiereDurchInteraktion() {
            if (animationsSchritt >= animationsSequenz.length) { 
                nenner = parseInt(nennerInput.value());
                zaehler = parseInt(zaehlerInput.value());
                if (isNaN(nenner) || nenner < 1) nenner = 1; if (nenner > 12) nenner = 12; 
                nennerInput.value(nenner);
                if (isNaN(zaehler) || zaehler < 0) zaehler = 0; if (zaehler > nenner) zaehler = nenner; 
                if (zaehler > 12) zaehler = 12; 
                zaehlerInput.elt.max = nenner; 
                zaehlerInput.value(zaehler); 
                if(schokoSketch) schokoSketch.redraw();
            }
        }
        
        function updateScore(points) {
            const newScore = score + points;
            const newLevel = getLevelForScore(newScore);
            const oldLevel = level;
            score = newScore;
            level = newLevel;

            if (newLevel > oldLevel) {
                 showLevelUpMessage(newLevel);
            }

            saveScore();
            updateScoreDisplay();
        }
        
        function getLevelForScore(currentScore) {
            for (let i = 0; i < LEVEL_UP_THRESHOLDS.length; i++) {
                if (currentScore < LEVEL_UP_THRESHOLDS[i]) {
                    return i + 1;
                }
            }
            return LEVEL_UP_THRESHOLDS.length + 1;
        }

        // --- HILFE-MODAL-LOGIK (Unver√§ndert) ---
        
        // New function to render math expressions as HTML
        function renderMathHtml(text) {
            // Replace fraction placeholders {z/n} with HTML structure
            let newText = text.replace(/{(\d+)\/(\d+)}/g, (match, z, n) => {
                return `<span class="frac-container"><span class="numerator">${z}</span><span class="fraction-bar"></span><span class="denominator">${n}</span></span>`;
            });
            // Replace multiplication placeholders {a*b} with HTML
            newText = newText.replace(/{(\d+)\*(\d+)}/g, (match, a, b) => {
                return `${a} &middot; ${b}`;
            });
            // Replace division placeholders {a:b} with HTML
            newText = newText.replace(/{(\d+):(\d+)}/g, (match, a, b) => {
                return `${a} : ${b}`;
            });
            return newText;
        }

        async function showHelp(taskType) {
            const helpModal = select('#helpModal');
            const helpContent = select('#helpContent');
            helpContent.html('<div id="problemAreaLoading"><div class="loader"></div><p>Lade Hilfe...</p></div>');
            helpModal.removeClass('hidden');

            let helpText;
            
            switch(taskType) {
                case 'visualFraction':
                case 'markFraction':
                    helpText = `
### Br√ºche ablesen/markieren

Um einen Bruch abzubilden oder zu verstehen, musst du diese Schritte gehen:

1.  **Schritt: Der Nenner (Unten):** Z√§hle alle Teile, in die das Ganze (z.B. deine Schokotafel) aufgeteilt ist. *Das ist dein Nenner.*
2.  **Schritt: Der Z√§hler (Oben):** Z√§hle oder markiere, wie viele dieser Teile eingef√§rbt oder hervorgehoben sind. *Das ist dein Z√§hler.*

**Beispiel:** Bei {3/4} musst du die Tafel zuerst in 4 Teile teilen und dann 3 Teile davon markieren.
`;
                    break;
                case 'fractionOfQuantity':
                    helpText = `
### So berechnest du Bruchteile von Mengen

Wenn du einen Bruchteil einer Menge berechnen willst, gibt es einen einfachen Trick:

1.  **Teilen durch den Nenner:** Nimm die Menge und teile sie durch die Zahl unten (den Nenner).
2.  **Malnehmen mit dem Z√§hler:** Nimm das Ergebnis und multipliziere es mit der Zahl oben (dem Z√§hler).

**Beispiel:**
Du hast 20 Kirschen und willst {1/4} davon essen.
1.  Teile die 20 Kirschen durch den Nenner 4: {20:4} = 5.
2.  Multipliziere das Ergebnis mit dem Z√§hler 1: {5*1} = 5.
{1/4} von 20 Kirschen sind also 5 Kirschen.
`;
                    break;
                case 'expandFraction':
                    helpText = `
### So erweiterst du Br√ºche

Br√ºche erweitern bedeutet, dass du Z√§hler und Nenner mit derselben Zahl multiplizierst. Dadurch ver√§ndern sich die Zahlen, aber der Wert des Bruches bleibt gleich.

**Warum macht man das?**
Stell dir vor, du hast die H√§lfte einer Schokolade ({1/2}). Das ist genau so viel wie {2/4} der Schokolade, oder {3/6}. Die St√ºcke sind kleiner geworden, aber die Menge ist dieselbe.

**Beispiel:**
Erweitere den Bruch {1/2} mit der Zahl 3.
* Z√§hler: {1*3} = 3
* Nenner: {2*3} = 6
Das Ergebnis ist {3/6}. Also ist {1/2} = {3/6}.
`;
                    break;
                case 'reduceFraction':
                    helpText = `
### So k√ºrzt du Br√ºche

Br√ºche k√ºrzen ist das Gegenteil von Erweitern. Du teilst Z√§hler und Nenner durch dieselbe Zahl, um den Bruch zu vereinfachen.

**Warum macht man das?**
Ein gek√ºrzter Bruch ist leichter zu verstehen. {2/4} ist dasselbe wie {1/2}.
Beim K√ºrzen suchst du die gr√∂√üte Zahl, durch die du Z√§hler und Nenner teilen kannst. Das ist der **gr√∂√üte gemeinsame Teiler**.

**Beispiel:**
K√ºrze den Bruch {6/9}.
* Welche Zahl teilt 6 und 9? Die 3.
* Z√§hler: {6:3} = 2
* Nenner: {9:3} = 3
Das Ergebnis ist {2/3}. Also ist {6/9} = {2/3}.
`;
                    break;
                case 'fractionToDecimal':
                    helpText = `
### So wandelst du Br√ºche in Dezimalzahlen um

Das ist ganz einfach! Du musst nur eine Sache tun:

**Teile den Z√§hler durch den Nenner.**

Das war's. Du nimmst die Zahl oben und teilst sie durch die Zahl unten. Das Ergebnis ist eine Kommazahl, also eine Dezimalzahl.

**Beispiel:**
Wandle den Bruch {1/4} in eine Dezimalzahl um.
* Z√§hler ist 1.
* Nenner ist 4.
* Rechnung: {1:4} = 0.25.
Das Ergebnis ist 0.25.
`;
                    break;
            }

            // A new method to parse markdown and render math expressions
            helpContent.html(parseMarkdownWithMath(helpText));
        }

        // --- New parsing function ---
        function parseMarkdownWithMath(text) {
            // First, process math placeholders
            let htmlText = renderMathHtml(text);

            // Then, handle markdown
            const lines = htmlText.split('\n');
            let formattedHtml = '';
            let inList = false;

            for (const line of lines) {
                const trimmedLine = line.trim();
                
                if (trimmedLine.startsWith('### ')) {
                    if (inList) {
                        formattedHtml += '</ul>';
                        inList = false;
                    }
                    formattedHtml += '<h3>' + trimmedLine.substring(4) + '</h3>';
                }
                else if (trimmedLine.includes('**')) {
                    if (inList) {
                        formattedHtml += '</ul>';
                        inList = false;
                    }
                    let boldedLine = trimmedLine.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    formattedHtml += '<p>' + boldedLine + '</p>';
                }
                else if (trimmedLine.startsWith('* ')) {
                    if (!inList) {
                        formattedHtml += '<ul>';
                        inList = true;
                    }
                    formattedHtml += '<li>' + trimmedLine.substring(2) + '</li>';
                }
                else if (trimmedLine !== '') {
                    if (inList) {
                        formattedHtml += '</ul>';
                        inList = false;
                    }
                    formattedHtml += '<p>' + trimmedLine + '</p>';
                }
            }
            if (inList) {
                formattedHtml += '</ul>';
            }
            return formattedHtml;
        }

        
        // --- INTERACTIVE MARKING FUNCTIONS (NEU) ---
        
        function handleMarkingClick(p, canvas, totalParts) {
            if (answered) return;
            
            // Definiere den Begrenzungsrahmen des Gitters (muss zur Zeichnung passen)
            const x = (p.width - interactiveTaskState.gridWidth) / 2;
            const y = (p.height - interactiveTaskState.gridHeight) / 2;
            const width = interactiveTaskState.gridWidth;
            const height = interactiveTaskState.gridHeight;
            
            if (p.mouseX > x && p.mouseX < x + width && p.mouseY > y && p.mouseY < y + height) {
                const partWidth = width / totalParts;
                
                // Berechne, welcher Teil angeklickt wurde
                const relativeX = p.mouseX - x;
                const clickedIndex = Math.floor(relativeX / partWidth);
                
                // Schalte den Zustand um (true/false)
                if (clickedIndex >= 0 && clickedIndex < totalParts) {
                    interactiveTaskState.markedParts[clickedIndex] = !interactiveTaskState.markedParts[clickedIndex];
                    p.redraw(); 
                }
            }
        }
        
        function drawInteractiveGrid(p, x, y, width, height, totalParts, markedParts) {
            p.push();
            p.translate(x, y);
            p.fill(240, 240, 240);
            p.stroke(0, 0, 0);
            p.strokeWeight(2);
            p.rect(0, 0, width, height, 8); 
            
            let partWidth = width / totalParts;
            
            p.noStroke();
            // Zeichne markierte (schattierte) Teile in Schoko-Farbe
            for (let i = 0; i < totalParts; i++) {
                if (markedParts[i]) {
                    p.fill(SCHOKO_FARBE_GENOMMEN); 
                    p.rect(i * partWidth, 0, partWidth, height);
                }
            }
            
            // Zeichne Gitternetzlinien oben
            p.stroke(LINIE_FARBE); // Wei√üe Linien wie bei der Schokotafel
            p.strokeWeight(3);
            for (let i = 1; i < totalParts; i++) {
                p.line(i * partWidth, 0, i * partWidth, height);
            }
            p.noStroke();
            p.pop();
        }
        
        function checkMarkingAnswer(correctNumerator) {
            if (answered) return;
            
            const markedCount = interactiveTaskState.markedParts.filter(m => m).length;
            
            const feedbackArea = select('#feedbackArea');
            const submitButton = select('#submitMarkingButton');
            const nextProblemButton = select('#nextProblemButton');
            
            answered = true; // Blockiere weitere Interaktion und das Senden
            submitButton.attribute('disabled', '');
            
            // Zeige Feedback an
            if (markedCount === correctNumerator) {
                feedbackArea.html("üéâ Richtig! Super gemacht! üéâ");
                feedbackArea.addClass('correct').removeClass('incorrect');
                updateScore(1);
            } else {
                feedbackArea.html(`ü§î Fast! Du hast ${markedCount} von ${interactiveTaskState.total_denominator} markiert, aber es sollten ${correctNumerator} sein.`);
                feedbackArea.addClass('incorrect').removeClass('correct');
                
                // Zeige die korrekte L√∂sung visuell an (markiere die ersten Z Teile)
                interactiveTaskState.markedParts = new Array(interactiveTaskState.total_denominator).fill(false);
                for(let i = 0; i < correctNumerator; i++) {
                    interactiveTaskState.markedParts[i] = true;
                }
                if (problemSketch) problemSketch.redraw();
            }
             nextProblemButton.removeClass('hidden');
        }

        // --- DISPLAY LOGIK (MODIFIZIERT) ---

        function displayProblem(data) {
            
            if (currentTaskType === 'markFraction') {
                // MARKIERUNGS-AUFGABE (Interaktiv)
                problemPageContent.html(`
                    <div id="problemCanvasContainer"></div>
                    <div id="problemText">${data.problem_text}</div>
                    <div id="feedbackArea"></div>
                    <div class="navigation-buttons">
                        <button id="submitMarkingButton">Antwort pr√ºfen! ‚úÖ</button>
                        <button id="nextProblemButton" class="hidden">N√§chste Aufgabe ‚ú®</button>
                    </div>
                `);

                // Initialisiere den Zustand
                const n = data.total_denominator;
                const z = data.correct_numerator;
                interactiveTaskState.correct_numerator = z;
                interactiveTaskState.total_denominator = n;
                interactiveTaskState.markedParts = new Array(n).fill(false);
                
                // Initialisiere den interaktiven p5 Sketch
                problemSketch = new p5(p => {
                    p.setup = function() {
                        let canvas = p.createCanvas(interactiveTaskState.canvasWidth, interactiveTaskState.canvasHeight);
                        canvas.parent('problemCanvasContainer');
                        // F√ºge den Klick-Handler hinzu
                        canvas.mousePressed(() => handleMarkingClick(p, canvas, n));
                    };
                    p.draw = function() {
                        p.background(247, 250, 255);
                        const x = (p.width - interactiveTaskState.gridWidth) / 2;
                        const y = (p.height - interactiveTaskState.gridHeight) / 2;
                        drawInteractiveGrid(p, x, y, interactiveTaskState.gridWidth, interactiveTaskState.gridHeight, n, interactiveTaskState.markedParts);
                    };
                });

                select('#submitMarkingButton').mousePressed(() => checkMarkingAnswer(z));
                select('#nextProblemButton').mousePressed(() => generateSpecificTaskLocal(currentTaskType));
                
                select('#problemCanvasContainer').removeClass('hidden');

            } else {
                // MEHRFACH-AUSWAHL-AUFGABEN (Bestehende Logik)
                problemPageContent.html(`
                    <div id="problemCanvasContainer"></div>
                    <div id="problemText">${data.problem_text}</div>
                    <div id="answerOptions"></div>
                    <div id="feedbackArea"></div>
                    <div class="navigation-buttons">
                        <button id="nextProblemButton" class="hidden">N√§chste Aufgabe ‚ú®</button>
                    </div>
                `);

                let answers = [data.correct_answer, ...data.wrong_answers];
                answers.sort(() => Math.random() - 0.5); 

                const answerOptionsDiv = select('#answerOptions');
                answers.forEach(answer => {
                    let btn = createButton(renderMathHtml(answer), 'answer-btn'); 
                    btn.attribute('data-value', answer); 
                    btn.parent(answerOptionsDiv);
                    btn.mousePressed(() => checkAnswer(answer, data.correct_answer));
                });
                
                const nextProblemButton = select('#nextProblemButton');
                nextProblemButton.mousePressed(() => generateSpecificTaskLocal(currentTaskType)); 
                
                if (problemSketch) {
                    problemSketch.remove();
                    problemSketch = null;
                }

                if (currentTaskType === 'visualFraction') {
                    const [z, n] = data.correct_answer.split('/').map(Number);
                    const visualType = ['pizza', 'grid'][Math.floor(Math.random() * 2)];
                     problemSketch = new p5(p => {
                        p.setup = function() {
                            let canvas = p.createCanvas(300, 220);
                            canvas.parent('problemCanvasContainer');
                        };
                        p.draw = function() {
                            p.background(247, 250, 255);
                            if (visualType === 'pizza') {
                                drawPizza(p, p.width / 2, p.height / 2, 80, n, z);
                            } else { 
                                drawGrid(p, (p.width - 200)/2, (p.height - 100)/2, 200, 100, n, z);
                            }
                        };
                    });
                    select('#problemCanvasContainer').removeClass('hidden');
                } else {
                     select('#problemCanvasContainer').addClass('hidden');
                }
            }
        }
        
        function checkAnswer(selected, correct) {
            if (answered) return;
            answered = true;

            const feedbackArea = select('#feedbackArea');
            const answerButtons = selectAll('.answer-btn');
            
            if (selected === correct) {
                feedbackArea.html("üéâ Richtig! Super gemacht! üéâ");
                feedbackArea.addClass('correct').removeClass('incorrect');
                updateScore(1);
            } else {
                feedbackArea.html("ü§î Fast! Versuch es nochmal!");
                feedbackArea.addClass('incorrect').removeClass('correct');
            }

            answerButtons.forEach(btn => {
                btn.attribute('disabled', ''); 
                if (btn.attribute('data-value') === correct) { 
                     btn.addClass('correct-outline');
                }
            });

            const nextProblemButton = select('#nextProblemButton');
            if (nextProblemButton) {
                nextProblemButton.removeClass('hidden');
            }
        }
        
        // --- Drawing Functions (reusable for both sketches) ---

        function mainDrawFunction(pInstance) {
            const p = pInstance || this; 
            p.background(255); 
            const aktuellerSchrittDetails = (animationsSchritt < animationsSequenz.length) ? animationsSequenz[animationsSchritt] : null;
            let nZeichnen = (animationsSchritt < animationsSequenz.length && nenner === -1) ? 2 : nenner; 
            let zZeichnen = (animationsSchritt < animationsSequenz.length && zaehler === -1) ? 0 : zaehler; 
            if (animationsSchritt >= animationsSequenz.length) { 
                nZeichnen = nenner;
                zZeichnen = zaehler;
            }
            zeichneSchokolade(p, RAND_ABSTAND, RAND_ABSTAND, SCHOKO_BREITE, SCHOKO_HOEHE, nZeichnen, zZeichnen, aktuellerSchrittDetails);
            let bruchCenterX = p.width / 2;
            let bruchCenterY = RAND_ABSTAND + SCHOKO_HOEHE + 40; 
            if (animationsSchritt >= animationsSequenz.length || (aktuellerSchrittDetails && aktuellerSchrittDetails.showBruchSymbol !== false) ) {
                let zDisplay = zZeichnen;
                let nDisplay = nZeichnen;
                let istPlatzhalter = false;
                if (animationsSchritt < animationsSequenz.length && nenner === -1 && zaehler === -1) { 
                    zDisplay = "Oben";
                    nDisplay = "Unten";
                    istPlatzhalter = true;
                } else if (animationsSchritt < animationsSequenz.length && aktuellerSchrittDetails.showOnlyNennerRelevant) {
                    zDisplay = ""; 
                }
                zeichneBruchHorizontal(p, zDisplay, nDisplay, bruchCenterX, bruchCenterY, istPlatzhalter, (animationsSchritt < animationsSequenz.length && aktuellerSchrittDetails.showOnlyNennerRelevant));
            }
        }

        function zeichneBruchHorizontal(p, z, n, x, y, istPlatzhalter = false, nurNennerRelevant = false) {
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(BRUCH_TEXT_GROESSE);
            let zText = istPlatzhalter ? "Oben" : (nurNennerRelevant && z === "" ? "" : p.str(z));
            let nText = istPlatzhalter ? "Unten" : p.str(n);
            let zTextBreite = p.textWidth(zText);
            let nTextBreite = p.textWidth(nText);
            let maxTextBreite = p.max(zTextBreite, nTextBreite);
            if (zText === "") maxTextBreite = nTextBreite; 
            let strichLaenge = maxTextBreite + 15; 
            if (zText !== "") { 
                p.fill(nurNennerRelevant && !istPlatzhalter ? 180 : ZAEHLER_FARBE);
                p.text(zText, x, y - BRUCH_TEXT_GROESSE * 0.3); 
            }
            p.stroke(BRUCHSTRICH_FARBE);
            p.strokeWeight(3);
            p.line(x - strichLaenge / 2, y + BRUCH_TEXT_GROESSE * 0.1, x + strichLaenge / 2, y + BRUCH_TEXT_GROESSE * 0.1); 
            p.noStroke();
            p.fill(NENNER_FARBE);
            p.text(nText, x, y + BRUCH_TEXT_GROESSE * 0.7); 
        }

        function zeichneSchokolade(p, x, y, breite, hoehe, aktuelleGesamtTeile, aktuelleGenommeneTeile, details) {
            p.fill(SCHOKO_FARBE_GANZ);
            p.noStroke();
            p.rect(x, y, breite, hoehe, 8);
            let numGesamtTeile = (aktuelleGesamtTeile === -1 ) ? 2 : aktuelleGesamtTeile; 
            let numGenommeneTeile = (aktuelleGenommeneTeile === -1) ? 0 : aktuelleGenommeneTeile;
            if (numGesamtTeile <= 0) return;
            let stueckBreite = breite / numGesamtTeile;
            if (!(details && details.showOnlyNennerRelevant && numGenommeneTeile === 0)) {
                p.fill(SCHOKO_FARBE_GENOMMEN);
                p.noStroke();
                for (let i = 0; i < numGenommeneTeile; i++) {
                    let aktuellesX = x + i * stueckBreite;
                    let ecken = [0,0,0,0];
                    if (i === 0) { ecken[0] = 8; ecken[3] = 8; }
                    if (i === numGenommeneTeile - 1) { ecken[1] = 8; ecken[2] = 8; }
                    if (numGenommeneTeile === numGesamtTeile) { 
                         if (i === 0) { ecken[0] = 8; ecken[3] = 8; }
                         if (i === numGesamtTeile - 1) { ecken[1] = 8; ecken[2] = 8; }
                    } else if (numGenommeneTeile === 1 && numGesamtTeile === 1) {
                        ecken = [8,8,8,8];
                    }
                    p.rect(aktuellesX, y, stueckBreite, hoehe, ecken[0], ecken[1], ecken[2], ecken[3]);
                }
            }
            if (details) { 
                p.strokeWeight(4); 
                if (details.nennerFokus) { p.stroke(FOKUS_UMRANDUNG_NENNER); p.noFill(); p.rect(x,y,breite,hoehe,8); }
                if (details.zaehlerFokus && numGenommeneTeile > 0 && !(details.showOnlyNennerRelevant)) { p.stroke(FOKUS_UMRANDUNG_ZAEHLER); p.noFill(); p.rect(x, y, stueckBreite * numGenommeneTeile, hoehe, 8); }
                p.noStroke(); 
            }
            p.stroke(LINIE_FARBE);
            p.strokeWeight(3); 
            for (let i = 1; i < numGesamtTeile; i++) {
                let linieX = x + i * stueckBreite;
                p.line(linieX, y, linieX, y + hoehe);
            }
            p.noStroke();
        }

        function drawPizza(p, x, y, radius, totalSlices, takenSlices) {
            p.push();
            p.translate(x, y);
            p.fill(242, 213, 168); 
            p.stroke(219, 178, 124);
            p.strokeWeight(4);
            p.ellipse(0, 0, radius * 2.2, radius * 2.2);
            p.fill(224, 78, 62); 
            p.noStroke();
            p.ellipse(0, 0, radius * 2, radius * 2);
            let angle = p.TWO_PI / totalSlices;
            p.fill(135, 206, 250);
            for (let i = 0; i < takenSlices; i++) {
                p.arc(0, 0, radius * 2, radius * 2, i * angle, (i + 1) * angle, p.PIE);
            }
            p.stroke(242, 213, 168, 150); 
            p.strokeWeight(2);
            for (let i = 0; i < totalSlices; i++) {
                p.line(0, 0, radius * p.cos(i * angle), radius * p.sin(i * angle));
            }
            p.pop();
        }
        
        function drawGrid(p, x, y, width, height, totalParts, shadedParts) {
            p.push();
            p.translate(x, y);
            p.fill(240, 240, 240);
            p.noStroke();
            p.rect(0, 0, width, height, 8);
        
            let partWidth = width / totalParts;
            
            p.fill(135, 206, 250);
            p.noStroke();
            for (let i = 0; i < shadedParts; i++) {
                p.rect(i * partWidth, 0, partWidth, height);
            }
            
            p.stroke(0, 0, 0);
            p.strokeWeight(2);
            for (let i = 1; i < totalParts; i++) {
                p.line(i * partWidth, 0, i * partWidth, height);
            }
            p.noStroke();
            p.pop();
        }
    </script>
</body>
</html>
